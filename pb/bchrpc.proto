syntax = "proto3";

package pb;

// Bitcoin Cash remote procedure calls is a protocol for communicating with a 
// bitcoin cash node from some client.  It is a set of methods, developed 
// for the bchd node, that can be exposed publicly via the command line options. 
//
// This service could be authenticated or unauthenticated.
//
service bchrpc {

    // Get info about the mempool.
    rpc GetMempoolInfo(GetMempoolInfoRequest) returns (GetMempoolInfoResponse) {}

    // Returns information about all of the transactions currently in the memory pool.
    // Offers an option to return full transactions or just transactions hashes.
    rpc GetMempool(GetMempoolRequest) returns (GetMempoolResponse) {}

    // GetBlockchainInfo info about the blockchain including the most recent
    // block hash and height.
    rpc GetBlockchainInfo(GetBlockchainInfoRequest) returns (GetBlockchainInfoResponse) {}

    // Get info about the given block.
    rpc GetBlockInfo(GetBlockInfoRequest)returns (GetBlockInfoResponse) {}

    // Get a block.
    rpc GetBlock(GetBlockRequest) returns (GetBlockResponse) {}

    // Get a serialized block.
    rpc GetRawBlock(GetRawBlockRequest) returns (GetRawBlockResponse) {}

    // Get a block filter.
    //
    // **Requires CfIndex**
    rpc GetBlockFilter(GetBlockFilterRequest) returns (GetBlockFilterResponse) {}

    // This RPC sends a block locator object to the server and the server responds with
    // a batch of no more than 2000 headers. Upon parsing the block locator, if the server
    // concludes there has been a fork, it will send headers starting at the fork point,
    // or genesis if no blocks in the locator are in the best chain. If the locator is
    // already at the tip no headers will be returned.
    rpc GetHeaders(GetHeadersRequest) returns (GetHeadersResponse) {}

    // Get a transaction given its hash.
    //
    // **Requires TxIndex**
    rpc GetTransaction(GetTransactionRequest) returns (GetTransactionResponse) {}

    // Get a serialized transaction given its hash.
    //
    // **Requires TxIndex**
    rpc GetRawTransaction(GetRawTransactionRequest) returns (GetRawTransactionResponse) {}

    // Returns the transactions for the given address. Offers offset,
    // limit, and from block options.
    //
    // **Requires AddressIndex**
    rpc GetAddressTransactions(GetAddressTransactionsRequest) returns (GetAddressTransactionsResponse) {}

    // Returns the raw transactions for the given address. Offers offset,
    // limit, and from block options.
    //
    // **Requires AddressIndex**
    rpc GetRawAddressTransactions(GetRawAddressTransactionsRequest) returns (GetRawAddressTransactionsResponse) {}

    // Returns all the unspent transaction outputs for the given address.
    //
    // **Requires AddressIndex**
    rpc GetAddressUnspentOutputs(GetAddressUnspentOutputsRequest) returns (GetAddressUnspentOutputsResponse) {}

    // Looks up the unspent output in the utxo set and returns the utxo metadata or not found.
    rpc GetUnspentOutput(GetUnspentOutputRequest) returns (GetUnspentOutputResponse) {}

    // Returns a merkle (SPV) proof that the given transaction is in the provided block.
    //
    // **Requires TxIndex***
    rpc GetMerkleProof(GetMerkleProofRequest) returns (GetMerkleProofResponse) {}

    // Submit a transaction to all connected peers.
    rpc SubmitTransaction(SubmitTransactionRequest) returns (SubmitTransactionResponse) {}

    // Subscribe to relevant transactions based on the subscription requests.
    //
    // This RPC does not use bi-directional streams and therefore can be used
    // with grpc-web. You will need to close and re-open the stream whenever
    // you want to update the addresses. If you are not using grpc-web
    // then SubscribeTransactionStream is more appropriate.
    //
    // **Requires TxIndex to receive input metadata**
    rpc SubscribeTransactions(SubscribeTransactionsRequest) returns (stream TransactionNotification) {}

    // Subscribe to relevant transactions based on the subscription requests.
    // The parameters to filter transactions on can be updated by sending new
    // SubscribeTransactionsRequest objects on the stream.
    //
    // Because this RPC is using bi-directional streaming it cannot be used with
    // grpc-web.
    //
    // **Requires TxIndex to receive input metadata**
    rpc SubscribeTransactionStream(stream SubscribeTransactionsRequest) returns (stream TransactionNotification) {}

    // Subscribe to notifications of new blocks being connected to the blockchain
    // or blocks being disconnected.
    rpc SubscribeBlocks(SubscribeBlocksRequest) returns (stream BlockNotification) {}
}


// RPC MESSAGES

message GetMempoolInfoRequest {}
message GetMempoolInfoResponse {
    // The count of transactions in the mempool
    uint32 size = 1;
    // The size in bytes of all transactions in the mempool 
    uint32 bytes = 2;
}

message GetMempoolRequest {
    // When true, full transaction data is provided instead of just transaction hashes.
    bool full_transactions = 1;
}

message GetMempoolResponse {
    message TransactionData {
        // Either one of the two following is provided, depending on the request.
        oneof txids_or_txs {
            // The transaction hash
            bytes transaction_hash = 1;
            // The transaction data
            Transaction transaction = 2;
        }
    }
    
    // List of unconfirmed transactions.
    repeated TransactionData transaction_data = 1;
}

message GetBlockchainInfoRequest {}
message GetBlockchainInfoResponse {

    // Bitcoin network types
    enum BitcoinNet {
        
        // Live public network with monetary value.
        MAINNET  = 0;
        // An isolated environment for automated testing.
        REGTEST  = 1;
        // A public environment where monetary value is agreed to be zero,
        // and some checks for transaction conformity are disabled.
        TESTNET3 = 2;
        // Private testnets for large scale simulations (or stress testing),
        // where a specified list of nodes is used, rather than node discovery.
        SIMNET   = 3;
    }

    // Which network the node is operating on.
    BitcoinNet bitcoin_net = 1;

    // The current number of blocks on the longest chain.
    int32 best_height = 2;
    // The hash of the block on the tip of the longest chain
    bytes best_block_hash = 3;
    // Threshold for adding new blocks.
    double difficulty = 4;
    // Median time of the last 11 blocks.
    int64 median_time = 5;
    // True if the node has full transaction index is enabled.
    bool tx_index = 6;
    // True if the node has address index is enabled.
    bool addr_index =7;
}

message GetBlockInfoRequest {
    oneof hash_or_height {
        // The block hash as a byte array or base64 encoded string, little-endian.
        bytes hash = 1;
        // The block number
        int32 height = 2;
    }
}
message GetBlockInfoResponse {
    // Marshaled block header data, as well as metadata.
    BlockInfo info = 1;
}

message GetBlockRequest {
    oneof hash_or_height {
        // The block hash as a byte array or base64 encoded string, little-endian.
        bytes hash = 1;
        // The block number
        int32 height = 2;
    }
    // Provide full transaction info instead of only hashes.
    bool full_transactions = 3;
}
message GetBlockResponse {
    // A marshaled block
    Block block = 1;
}

message GetRawBlockRequest {
    oneof hash_or_height {
        // The block hash as a byte array or base64 encoded string, little-endian.
        bytes hash = 1;
        // The block number
        int32 height = 2;
    }
}
message GetRawBlockResponse {
    // Raw block data 
    bytes block = 1;
}

message GetBlockFilterRequest {
    oneof hash_or_height {
        // The block hash as a byte array or base64 encoded string, little-endian.
        bytes hash = 1;
        // The block number
        int32 height = 2;
    }
}

message GetBlockFilterResponse {
    bytes filter = 1;
}

message GetHeadersRequest {
    repeated bytes block_locator_hashes = 1;
    bytes stop_hash = 2;
}
message GetHeadersResponse {
    // List of block headers
    repeated BlockInfo headers = 1;
}

// Get a transaction from a transaction hash
message GetTransactionRequest {
    // A transaction hash
    bytes hash = 1;
}
message GetTransactionResponse {
    // A marshaled transaction
    Transaction transaction = 1;
}

// Get an encoded transaction from a transaction hash
message GetRawTransactionRequest {
    // A transaction hash
    bytes hash = 1;
}
message GetRawTransactionResponse {
    // Raw transaction in bytes
    bytes transaction = 1;
}

// GetAddressTransactionsRequest obtains transactions related to a specific address
//
// RECOMMENDED:
// Parameters have been provided to query without creating 
//   performance issues on the node or client.
//
// - The number of transactions to skip and fetch allow for iterating
//       over a large set of transactions, if necessary.
//
// - A starting block parameter (either `hash` or `height`) 
//       may then be used to filter results to those occuring
//       after a certain time.
//
// This approach will reduce network traffic and response processing 
//   for the client, as well as reduce workload on the node.
// The paging and start_block parameters are not applied to 
//   unconfirmed transactions. 
message GetAddressTransactionsRequest {

    // The address to query transactions, in lowercase cashaddr format.
    // The network prefix is optional (i.e. "cashaddress:").
    string address = 1;

    // Skip some number of confirmed transactions.
    // Does not affect results of unconfirmed transactions.
    uint32 nb_skip = 2;
    // Only fetch a specific number of transactions, at a time.
    uint32 nb_fetch = 3;


    oneof start_block {
        // Recommended: Only return transactions after a starting block identified by hash.
        bytes hash = 4;
        // Recommended: Only return transactions after a starting block identified by block number.
        int32 height = 5;
    }
}
message GetAddressTransactionsResponse {

    // Transactions that have been included in a block.
    repeated Transaction confirmed_transactions = 1;
    // Transactions in mempool which have not been included in a block.
    repeated MempoolTransaction unconfirmed_transactions = 2;
}

// Get encoded transactions related to a specific address
//
// RECOMMENDED:
// Parameters have been provided to query without creating 
//   performance issues on the node or client.
//
// - The number of transactions to skip and fetch allow for iterating
//       over a large set of transactions, if necessary.
//
// - A starting block parameter (either `hash` or `height`) 
//       may then be used to filter results to those occuring
//       after a certain time.
//
// This approach will reduce network traffic and response processing 
//   for the client, as well as reduce workload on the node.
// The paging and start_block parameters are not applied to 
//   unconfirmed transactions. 
message GetRawAddressTransactionsRequest {

    // The address to query transactions, in lowercase cashaddr format.
    // The network prefix is optional (i.e. "cashaddress:").
    string address = 1;

    // The number of confirmed transactions to skip starting with the oldest first.
    // Does not affect results of unconfirmed transactions.
    uint32 nb_skip = 2;
    // The total number of transactions to be fetched.
    uint32 nb_fetch = 3;

    oneof start_block {
        // Recommended: Only return transactions after a starting block identified by hash.
        bytes hash = 4;
        // Recommended: Only return transactions after a starting block identified by block number.
        int32 height = 5;
    }
}
message GetRawAddressTransactionsResponse {
    // Transactions that have been in a block.
    repeated bytes confirmed_transactions = 1;
    // Transactions in mempool which have not been included in a block.
    repeated bytes unconfirmed_transactions = 2;
}

message GetAddressUnspentOutputsRequest {
    // The address to query transactions, in lowercase cashaddr format.
    // The network prefix is optional (i.e. "cashaddress:").
    string address = 1;
    // When include_mempool is true, unconfirmed transactions from mempool are returned. Default is false.
    bool include_mempool = 2;
}
message GetAddressUnspentOutputsResponse {
    // List of unspent outputs
    repeated UnspentOutput outputs = 1;
}

message GetUnspentOutputRequest {
    bytes hash = 1;
    // The number of the output, starting from zero.
    uint32 index = 2;
    // When include_mempool is true, unconfirmed transactions from mempool are returned. Default is false.
    bool include_mempool = 3;
}
message GetUnspentOutputResponse {

    // A reference to the related input
    Transaction.Input.Outpoint outpoint = 1;
    bytes pubkey_script = 2;
    // Amount in satoshi
    int64 value = 3;

    bool is_coinbase = 4;
    int32 block_height = 5;
}

message GetMerkleProofRequest {
    bytes transaction_hash = 1;
}
message GetMerkleProofResponse {
    BlockInfo block = 1;
    repeated bytes hashes = 2;
    bytes flags = 3;
}

message SubmitTransactionRequest {
    // The encoded transaction
    bytes transaction = 1;
}
message SubmitTransactionResponse {
    bytes hash = 1;
}

// Request to subscribe or unsubscribe from a stream of transactions
message SubscribeTransactionsRequest {
    TransactionFilter subscribe = 1;
    TransactionFilter unsubscribe = 2;

    // When include_mempool is true, new unconfirmed transactions from mempool are
    // included apart from the ones confirmed in a block.
    bool include_mempool = 3;

    // When include_in_block is true, transactions are included when they are confirmed.
    // This notification is sent in addition to any requested mempool notifications.
    bool include_in_block = 4;

    // When serialize_tx is true, transactions are serialized using bitcoin protocol encoding. 
    // Default is false, transaction will be Marshaled (see `Transaction`, `MempoolTransaction` and `TransactionNotification`)
    bool serialize_tx = 5;
}

// Options to define data structure to be sent by SubscribeBlock stream:
//
//  - BlockInfo (block metadata): `BlockInfo`
//      - SubscribeBlocksRequest {}
//
//  - Marshaled Block (with transaction hashes): `Block`
//      - SubscribeBlocksRequest {
//            full_block = true
//        }
//  - Marshaled Block (with full transaction data): `Block`
//      - SubscribeBlocksRequest {
//            full_block = true
//            full_transactions = true
//        }
//  - Serialized Block acccording to bitcoin protocol encoding: `bytes`
//      - SubscribeBlocksRequest {
//            serialize_block = true
//        }
message SubscribeBlocksRequest {

    // When full_block is true, a complete marshaled block is sent. See `Block`.
    // Default is false, block metadata is sent. See `BlockInfo`.
    bool full_block = 1;

    // When full_transactions is true, provide full transaction info for a marshaled block.
    // Default is false, only the transaction hashes are included for a marshaled block. See `TransactionData`.
    bool full_transactions = 2;

    // When serialize_block is true, blocks are serialized using bitcoin protocol encoding. 
    // Default is false, block will be Marshaled (see `BlockInfo` and `BlockNotification`)
    bool serialize_block = 3;
}


// NOTIFICATIONS


message BlockNotification {

    // State of the block in relation to the chain.
    enum Type {
        CONNECTED = 0;
        DISCONNECTED = 1;
    }

    // Whether the block is connected to the chain.
    Type type = 1;
    oneof block {
        // Marshaled block header data, as well as metadata stored by the node.
        BlockInfo block_info = 2;
        // A Block 
        Block marshaled_block = 3;
        // Binary block, serialized using bitcoin protocol encoding.
        bytes serialized_block = 4;
    }
}

message TransactionNotification {
    
    // State of the transaction acceptance.
    enum Type {
        // A transction in mempool.
        UNCONFIRMED = 0;
        // A transaction in a block.
        CONFIRMED   = 1;
    }

    // Whether or not the transaction has been included in a block
    Type type = 1;
    oneof transaction {
        // A transaction included in a block.
        Transaction confirmed_transaction = 2;
        // A broadcasted transaction in mempool.
        MempoolTransaction unconfirmed_transaction = 3;
        // Binary transaction, serialized using bitcoin protocol encoding.
        bytes serialized_transaction = 4;
    }
}


// DATA MESSAGES

// Metadata for identifying and validating a block 
message BlockInfo {

    // Identification.
    
    // The repeated sha256 hash of the six header fields encoded according the protocol.
    // sha256(sha256(encoded_header))
    bytes hash = 1;
    // The block number, an incremental index for each block mined.
    int32 height = 2;

    // Block header data.

    // A version number to track software/protocol upgrades.
    int32 version = 3;
    // Hash of the previous block
    bytes previous_block = 4;
    // The root of the merkle tree built from all transactions in the block.
    bytes merkle_root = 5;
    // When mining of the block started, expressed in seconds since 1970-01-01.
    int64 timestamp = 6;
    // Difficulty in Compressed Target Format
    uint32 bits = 7;
    // A random value that was generated during block mining which happend to
    // result in a computed block hash below the difficulty target at the time.
    uint32 nonce = 8;

    // Metadata.
    
    // Number of blocks in a chain, including the block itself upon creation.
    int32 confirmations = 9;
    // Difficulty target at time of creation
    double difficulty = 10;
    // Hash of the next block
    bytes next_block_hash = 11;
    // Size of the block in bytes
    int32 size = 12;
    // The median block time of the latest 11 block timestamps
    int64 median_time = 13;
}

message Block {
    message TransactionData {
        // Either one of the two following is provided, depending on the request.
        oneof txids_or_txs {
            bytes transaction_hash = 1;
            Transaction transaction = 2;
        }
    }
    // Block header data, as well as metadata stored by the node.
    BlockInfo info = 1;
    // List of transactions or transaction hashes.
    repeated TransactionData transaction_data = 2;
}

message Transaction {
    message Input {
        message Outpoint {
            // The hash of the transaction containing the output to be spent.
            bytes hash = 1;
            // The txout index of the outpoint.
            uint32 index = 2;
        }
        // The number of the input, starting from zero.
        uint32 index = 1;
        
        // The related outpoint
        Outpoint outpoint = 2;
        // The signature script used to redeem the origin transaction
        bytes signature_script = 3;
        // As of BIP-68, the sequence number is interpreted as a relative lock-time for the input.
        uint32 sequence = 4;
        // Amount in satoshi
        int64 value = 5;
        // The hash of the transaction containing the output to be spent.
        bytes previous_script = 6;
        // The bitcoin addresses associated with this input.
        string address = 7;
    }
    message Output {
        // The number of the output, starting from zero.
        uint32 index = 1;
        // The number of satoshis to be transferred.
        int64 value = 2;
        // The public key script used to pay coins.
        bytes pubkey_script = 3;
        // The bitcoin addresses associated with this output.
        string address = 4;
        // The type of script.
        string script_class = 5;
        // TODO-DOC? be more descriptive: disassembly of the script
        string disassembled_script = 6;
    }

    // The double sha256 hash of the encoded transaction.
    // sha256(sha256(encoded_transaction))
    bytes hash = 1;
    // The version of the transaction format.
    int32 version = 2;
    // List of inputs 
    repeated Input inputs = 3;
    // List of outputs
    repeated Output outputs = 4;
    // The block height or timestamp after which this transaction is allowed. 
    // If value is greater than 500 million, it is assumed to be an epoch timestamp,
    // otherwise it is treated as a block-height.
    uint32 lock_time = 5;

    // Metadata

    // The size of the transaction in bytes
    int32 size = 8;
    // When the transaction was included in a block, in epoch time.
    int64 timestamp = 9;
    // Number of blocks including proof of the transaction, including the block it appeared.
    int32 confirmations = 10;
    // Number of the block containing the transaction.
    int32 block_height = 11;
    // Hash of the block the transaction was recorded in.
    bytes block_hash = 12;
}

message MempoolTransaction {
    Transaction transaction = 1;

    // When the transaction was witnessed by the node.
    int64 added_time = 2;
    // The block height at the time the transaction was added to the pool.
    int32 added_height = 3;
    // The total fee in satoshi the transaction pays.
    int64 fee = 4;
    // The fee in satoshi per kilobyte the transaction pays.
    int64 fee_per_kb = 5;
    // The priority of the transaction when it was added to the pool.
    double starting_priority = 6;
}

message UnspentOutput {
    Transaction.Input.Outpoint outpoint = 1;
    // The public key script used to pay coins.
    bytes pubkey_script = 2;
    // The amount in satoshis 
    int64 value = 3;
    // Whether or not the input is a generation transaction, the result of mining.
    bool is_coinbase = 4;
    // The block number containing the UXTO.
    int32 block_height = 5;
}

message TransactionFilter {

    // Filter by address(es)
    repeated string addresses = 1;

    // TODO-DOCS: ? Filter by output hash and index
    repeated Transaction.Input.Outpoint outpoints = 2;

    // TODO-DOCS: ? Specify which transaction elements to return
    repeated bytes data_elements = 3;

    //TODO: Are these extra filters values relevant?
    // - scriptPubkey

    // Subscribed/Unsubscribe to everything. Other filters
    // will be ignored.
    bool all_transactions = 4;
}
